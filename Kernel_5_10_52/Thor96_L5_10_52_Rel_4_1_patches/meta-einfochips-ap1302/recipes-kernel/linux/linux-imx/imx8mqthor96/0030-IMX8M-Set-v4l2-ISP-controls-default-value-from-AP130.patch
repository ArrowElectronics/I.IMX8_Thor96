From 4b116dc6d21ee3f455e5e6b8a523a12c2726787d Mon Sep 17 00:00:00 2001
From: Deepak Rathore <deepak.rathore@einfochips.com>
Date: Thu, 10 Mar 2022 13:24:21 +0530
Subject: [PATCH] IMX8M: Set v4l2 ISP controls default value from AP1302

- During boot up read ISP control register values related to v4l2
  control and set it as default value in v4l2 layer from ap1302 driver
- Return type of sysfs entry for writing AP1302 register is corrected
- Changed ARX3A0 resolution to 600x600

Change-Id: I8ccee1a98f4d846ba86b73c9e70e3a44bb3bf7a1
Signed-off-by: Deepak Rathore <deepak.rathore@einfochips.com>

diff --git a/drivers/media/i2c/ap1302.c b/drivers/media/i2c/ap1302.c
index 6349286b3..c0db73602 100644
--- a/drivers/media/i2c/ap1302.c
+++ b/drivers/media/i2c/ap1302.c
@@ -36,7 +36,7 @@
 #define AP1302_MIN_WIDTH			24U
 #define AP1302_MIN_HEIGHT			16U
 #define AP1302_MAX_WIDTH			4224U
-#define AP1302_MAX_HEIGHT			4092U
+#define AP1302_MAX_HEIGHT			3156U
 
 #define AP1302_REG_16BIT(n)			((2 << 24) | (n))
 #define AP1302_REG_32BIT(n)			((4 << 24) | (n))
@@ -376,6 +376,10 @@
 #define AP1302_TCLK_PRE_MASK			0xFF00
 #define AP1302_TCLK_PRE_SHIFT			0x8
 
+#define AP1302_V4L2_CTRLS			7
+#define AWB_MODE_0				0x00000000
+#define AWB_MODE_1				0x00000001
+
 struct ap1302_device;
 
 enum {
@@ -486,6 +490,17 @@ struct ap1302_firmware_header {
 	u32 dummy;
 } __packed;
 
+enum ap1302_v4l2_ctrls
+{
+	AP1302_CTRL_WB=0,
+	AP1302_CTRL_GAMMA,
+	AP1302_CTRL_CONTRAST,
+	AP1302_CTRL_BRIGHTNESS,
+	AP1302_CTRL_SATURATION,
+	AP1302_CTRL_EXPOSURE,
+	AP1302_CTRL_GAIN
+};
+
 #define MAX_FW_LOAD_RETRIES 3
 
 static const struct ap1302_format_info supported_video_formats[] = {
@@ -542,7 +557,7 @@ static const struct ap1302_sensor_info ap1302_sensor_info[] = {
 		.model = "onnn,arx3a0",
 		.name = "arx3a0",
 		.i2c_addr = 0x36,
-		.resolution = { 1280, 720 },
+		.resolution = { 600, 600 },
 		.fps = 120,
 		.format = MEDIA_BUS_FMT_UYVY8_2X8,
 		.supplies = (const struct ap1302_sensor_supply[]) {
@@ -954,7 +969,7 @@ static int ap1302_reg_data_set(void *arg, u64 val)
 		goto unlock;
 	}
 
-	ap1302_write(ap1302, addr, val, &ret);
+	ap1302_write(ap1302, addr, val, NULL);
 
 unlock:
 	mutex_unlock(&ap1302->debugfs.lock);
@@ -1463,7 +1478,7 @@ static const struct v4l2_ctrl_ops ap1302_ctrl_ops = {
 	.s_ctrl = ap1302_s_ctrl,
 };
 
-static const struct v4l2_ctrl_config ap1302_ctrls[] = {
+static struct v4l2_ctrl_config ap1302_ctrls[] = {
 	{
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
@@ -1475,37 +1490,33 @@ static const struct v4l2_ctrl_config ap1302_ctrls[] = {
 		.id = V4L2_CID_GAMMA,
 		.name = "Gamma",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = 0x0100,
+		.min = 0x0000,
 		.max = 0xFFFF,
-		.step = 0x100,
-		.def = 0x1000,
+		.step = 0x0001,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_CONTRAST,
 		.name = "Contrast",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = 0x100,
+		.min = 0x0000,
 		.max = 0xFFFF,
-		.step = 0x100,
-		.def = 0x100,
+		.step = 0x0001,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_BRIGHTNESS,
 		.name = "Brightness",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = 0x100,
+		.min = 0x0000,
 		.max = 0xFFFF,
-		.step = 0x100,
-		.def = 0x100,
+		.step = 0x0001,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_SATURATION,
 		.name = "Saturation",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = 0x0100,
+		.min = 0x0000,
 		.max = 0xFFFF,
-		.step = 0x100,
-		.def = 0x1000,
+		.step = 0x0001,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_EXPOSURE,
@@ -1514,24 +1525,91 @@ static const struct v4l2_ctrl_config ap1302_ctrls[] = {
 		.min = 0x0,
 		.max = 0xC,
 		.step = 1,
-		.def = 0xC,
 	}, {
 		.ops = &ap1302_ctrl_ops,
 		.id = V4L2_CID_GAIN,
 		.name = "Gain",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = 0x0100,
+		.min = 0x0000,
 		.max = 0xFFFF,
-		.step = 0x100,
-		.def = 0x100,
+		.step = 0x0001,
 	},
 };
 
+static int ap1302_get_ctrls(struct ap1302_device *ap1302)
+{
+	int ret=0;
+	u32 val=0x00000000;
+
+	/* get the CONTRAST value form AP1302 */
+	ret=ap1302_read(ap1302, AP1302_CONTRAST, &val);
+	if (ret < 0)
+		return ret;
+
+	ap1302_ctrls[AP1302_CTRL_CONTRAST].def = val;
+
+	/* get the BRIGHTNESS value form AP1302 */
+	val=0x00000000;
+	ret=ap1302_read(ap1302, AP1302_BRIGHTNESS, &val);
+	if (ret < 0)
+		return ret;
+
+	ap1302_ctrls[AP1302_CTRL_BRIGHTNESS].def = val;
+
+	/* get the SATURATION value form AP1302 */
+	val=0x00000000;
+	ret=ap1302_read(ap1302, AP1302_SATURATION, &val);
+	if (ret < 0)
+		return ret;
+
+	ap1302_ctrls[AP1302_CTRL_SATURATION].def = val;
+
+	/* get the GAMMA value form AP1302 */
+	val=0x00000000;
+	ret=ap1302_read(ap1302, AP1302_GAMMA, &val);
+	if (ret < 0)
+		return ret;
+
+	ap1302_ctrls[AP1302_CTRL_GAMMA].def = val;
+
+	/* get the GAIN value form AP1302 */
+	val=0x00000000;
+	ret=ap1302_read(ap1302, AP1302_AE_MANUAL_GAIN, &val);
+	if (ret < 0)
+		return ret;
+
+	ap1302_ctrls[AP1302_CTRL_GAIN].def = val;
+
+	/* get the EXPOSURE value form AP1302 */
+	val=0x00000000;
+	ret=ap1302_read(ap1302, AP1302_AE_CTRL, &val);
+	if (ret < 0)
+		return ret;
+	val = val & AP1302_AE_CTRL_MODE_MASK;
+	ap1302_ctrls[AP1302_CTRL_EXPOSURE].def = val;
+
+	/* get the WHITE BALANCE value form AP1302 */
+	val=0x00000000;
+	ret=ap1302_read(ap1302, AP1302_AWB_CTRL, &val);
+	if (ret < 0)
+		return ret;
+
+	val &= AP1302_AWB_CTRL_MODE_MASK;
+	val = (val != AP1302_AWB_CTRL_MODE_AUTO)? AWB_MODE_0 : AWB_MODE_1;
+	ap1302_ctrls[AP1302_CTRL_WB].def = val;
+
+	return ret;
+}
+
 static int ap1302_ctrls_init(struct ap1302_device *ap1302)
 {
 	unsigned int i;
 	int ret;
 
+	ret = ap1302_get_ctrls(ap1302);
+	if (ret)
+		return ret;
+
 	ret = v4l2_ctrl_handler_init(&ap1302->ctrls, ARRAY_SIZE(ap1302_ctrls));
 	if (ret)
 		return ret;
-- 
2.17.1

