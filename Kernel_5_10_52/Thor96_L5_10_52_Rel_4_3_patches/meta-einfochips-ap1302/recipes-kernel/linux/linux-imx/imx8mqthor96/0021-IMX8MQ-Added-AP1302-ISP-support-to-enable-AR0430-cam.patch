From ea1d17890329ea450de0971fd129df022b0dcf0c Mon Sep 17 00:00:00 2001
From: Deepak Rathore <deepak.rathore@einfochips.com>
Date: Tue, 8 Mar 2022 20:40:36 +0530
Subject: [PATCH 06/10] IMX8MQ: Added AP1302 ISP support to enable AR0430
 camera sensor

- Enables AP1302 as loadable module in imx_v8_defconfig
- Updates the frequency of MIPI CSI1 of IMX8MQ, to get
  4 data lane working
- Added new DTS imx8mq-thor96-ap1302-ar0430.dts for AR0430
- Added changes in AP1302 driver so that it can work on IMX platforms
- Increases CMA size,so that gstreamer can work on higher resolution
- Added reserved memory node in DTS to increase CMA pool size

Change-Id: I14cfbddc7b786f4bd13f51916103efc665514cf3
Signed-off-by: Deepak Rathore <deepak.rathore@einfochips.com>
---
 arch/arm64/boot/dts/freescale/Makefile        |   2 +-
 .../freescale/imx8mq-thor96-ap1302-ar0430.dts |  67 ++
 .../boot/dts/freescale/imx8mq-thor96.dts      |  14 +
 arch/arm64/boot/dts/freescale/imx8mq.dtsi     |   2 +-
 arch/arm64/configs/imx_v8_defconfig           |   3 +-
 drivers/media/i2c/ap1302.c                    | 586 ++++++++----------
 6 files changed, 351 insertions(+), 323 deletions(-)
 create mode 100644 arch/arm64/boot/dts/freescale/imx8mq-thor96-ap1302-ar0430.dts

diff --git a/arch/arm64/boot/dts/freescale/Makefile b/arch/arm64/boot/dts/freescale/Makefile
index cabf63cb9..f59fc6099 100644
--- a/arch/arm64/boot/dts/freescale/Makefile
+++ b/arch/arm64/boot/dts/freescale/Makefile
@@ -123,7 +123,7 @@ dtb-$(CONFIG_ARCH_MXC) += imx8mq-nitrogen.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-phanbell.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-pico-pi.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-thor96.dtb imx8mq-thor96-dual-display.dtb imx8mq-thor96-dcss-rm67191.dtb \
-			  imx8mq-thor96-lcdif-adv7535.dtb
+			  imx8mq-thor96-lcdif-adv7535.dtb imx8mq-thor96-ap1302-ar0430.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-dp.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-zii-ultra-rmb3.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-zii-ultra-zest.dtb
diff --git a/arch/arm64/boot/dts/freescale/imx8mq-thor96-ap1302-ar0430.dts b/arch/arm64/boot/dts/freescale/imx8mq-thor96-ap1302-ar0430.dts
new file mode 100644
index 000000000..b96fcf0e3
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mq-thor96-ap1302-ar0430.dts
@@ -0,0 +1,67 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2019 NXP.
+ */
+
+#include "imx8mq-thor96.dts"
+
+&ov5640_mipi2 {
+	status = "disabled";
+};
+
+&ov5640_mipi {
+	status = "disabled";
+};
+
+&i2c3 {
+	ap1302_mipi: ap1302@3d {
+		compatible = "onnn,ap1302";
+		reg = <0x3d>;
+
+		pinctrl-0 = <&pinctrl_csi>;
+		clocks = <&clk IMX8MQ_CLK_CLKO2>;
+		clock-names = "xclk";
+		assigned-clocks = <&clk IMX8MQ_CLK_CLKO2>,
+				  <&clk IMX8MQ_CLK_CLKO2>;
+		assigned-clock-parents = <&clk IMX8MQ_SYS2_PLL_200M>;
+		assigned-clock-rates = <0>, <20000000>;
+
+		reset-gpios = <&gpio3 24 GPIO_ACTIVE_LOW>;
+		standby-gpios = <&gpio2 7 GPIO_ACTIVE_HIGH>;
+		i2csel-gpios = <&gpio2 8 GPIO_ACTIVE_HIGH>;
+		isptrig-gpios = <&gpio3 12 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+
+		port {
+			ap1302_ep: endpoint {
+				remote-endpoint = <&mipi1_sensor_ep>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+
+		sensors {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			onnn,model = "onnn,ar0430";
+			sensor@0 {
+				reg = <0>;
+			};
+		};
+	};
+};
+
+&mipi1_sensor_ep {
+	remote-endpoint = <&ap1302_ep>;
+	data-lanes = <1 2 3 4>;
+	csis-wclk;
+};
+
+&iomuxc {
+	pinctrl_csi: csi_grp {
+		fsl,pins = <
+			MX8MQ_IOMUXC_SD1_DATA5_GPIO2_IO7	0x19
+			MX8MQ_IOMUXC_SAI5_RXD3_GPIO3_IO24	0x19
+			MX8MQ_IOMUXC_GPIO1_IO15_CCMSRCGPCMIX_CLKO2      0x59
+		>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mq-thor96.dts b/arch/arm64/boot/dts/freescale/imx8mq-thor96.dts
index 6415c8ff6..a32062a22 100644
--- a/arch/arm64/boot/dts/freescale/imx8mq-thor96.dts
+++ b/arch/arm64/boot/dts/freescale/imx8mq-thor96.dts
@@ -30,6 +30,20 @@
 		reg = <0x00000000 0x40000000 0 0x80000000>;
 	};
 
+	resmem: reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0 0x38000000>;
+			alloc-ranges = <0 0x80000000 0 0x38000000>;
+			linux,cma-default;
+		};
+	};
+
 	leds {
 		compatible = "gpio-leds";
 		pinctrl-names = "default";
diff --git a/arch/arm64/boot/dts/freescale/imx8mq.dtsi b/arch/arm64/boot/dts/freescale/imx8mq.dtsi
index 8cd660a22..a434ed697 100755
--- a/arch/arm64/boot/dts/freescale/imx8mq.dtsi
+++ b/arch/arm64/boot/dts/freescale/imx8mq.dtsi
@@ -1139,7 +1139,7 @@
 				assigned-clocks = <&clk IMX8MQ_CLK_CSI1_CORE>,
 						  <&clk IMX8MQ_CLK_CSI1_PHY_REF>,
 						  <&clk IMX8MQ_CLK_CSI1_ESC>;
-				assigned-clock-rates = <133000000>, <100000000>, <66000000>;
+				assigned-clock-rates = <266000000>, <333000000>, <66000000>;
 				power-domains = <&pgc_mipi_csi1>;
 				csis-phy-reset = <&src 0x4c 7>;
 				phy-gpr = <&iomuxc_gpr 0x88>;
diff --git a/arch/arm64/configs/imx_v8_defconfig b/arch/arm64/configs/imx_v8_defconfig
index c5879e93d..f04d9d73c 100644
--- a/arch/arm64/configs/imx_v8_defconfig
+++ b/arch/arm64/configs/imx_v8_defconfig
@@ -525,6 +525,7 @@ CONFIG_MXC_MIPI_CSI=y
 CONFIG_MXC_CAMERA_OV5640_MIPI_V2=y
 CONFIG_V4L_MEM2MEM_DRIVERS=y
 CONFIG_SDR_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_AP1302=m
 CONFIG_VIDEO_IMX219=m
 CONFIG_VIDEO_OV5640=y
 CONFIG_VIDEO_OV5645=m
@@ -963,7 +964,7 @@ CONFIG_CRYPTO_DEV_HISI_HPRE=m
 CONFIG_CRYPTO_DEV_AMLOGIC_GXL=m
 CONFIG_INDIRECT_PIO=y
 CONFIG_CRC_CCITT=m
-CONFIG_CMA_SIZE_MBYTES=32
+CONFIG_CMA_SIZE_MBYTES=256
 CONFIG_PRINTK_TIME=y
 CONFIG_DEBUG_INFO=y
 CONFIG_MAGIC_SYSRQ=y
diff --git a/drivers/media/i2c/ap1302.c b/drivers/media/i2c/ap1302.c
index 96da195c6..e525714e3 100644
--- a/drivers/media/i2c/ap1302.c
+++ b/drivers/media/i2c/ap1302.c
@@ -28,13 +28,15 @@
 
 #define DRIVER_NAME "ap1302"
 
+#define AR0430_MODEL   "onnn,ar0430"
+
 #define AP1302_FW_WINDOW_SIZE			0x2000
 #define AP1302_FW_WINDOW_OFFSET			0x8000
 
 #define AP1302_MIN_WIDTH			24U
 #define AP1302_MIN_HEIGHT			16U
 #define AP1302_MAX_WIDTH			4224U
-#define AP1302_MAX_HEIGHT			4092U
+#define AP1302_MAX_HEIGHT			3156U
 
 #define AP1302_REG_16BIT(n)			((2 << 24) | (n))
 #define AP1302_REG_32BIT(n)			((4 << 24) | (n))
@@ -110,6 +112,9 @@
 #define AP1302_PREVIEW_ROI_X1			AP1302_REG_16BIT(0x2008)
 #define AP1302_PREVIEW_ROI_Y1			AP1302_REG_16BIT(0x200a)
 #define AP1302_PREVIEW_OUT_FMT			AP1302_REG_16BIT(0x2012)
+#define AP1302_PREVIEW_MIPI_CTRL		AP1302_REG_16BIT(0x2016)
+#define AP1302_PREVIEW_SENSOR_MODE		AP1302_REG_16BIT(0x2014)
+#define AP1302_PREVIEW_MAX_FPS			AP1302_REG_16BIT(0x2020)
 #define AP1302_PREVIEW_OUT_FMT_IPIPE_BYPASS	BIT(13)
 #define AP1302_PREVIEW_OUT_FMT_SS		BIT(12)
 #define AP1302_PREVIEW_OUT_FMT_FAKE_EN		BIT(11)
@@ -164,6 +169,19 @@
 #define AP1302_PREVIEW_HINF_CTRL_SPOOF		BIT(4)
 #define AP1302_PREVIEW_HINF_CTRL_MIPI_MODE	BIT(3)
 #define AP1302_PREVIEW_HINF_CTRL_MIPI_LANES(n)	((n) << 0)
+#define AP1302_SYSTEM_FREQ_IN		AP1302_REG_32BIT(0x6024)
+#define AP1302_SIPM_FREQ		AP1302_REG_32BIT(0x6028)
+#define AP1302_PLL_0_DIV		AP1302_REG_32BIT(0x602C)
+#define AP1302_PLL_1_DIV		AP1302_REG_32BIT(0x6038)
+#define AP1302_PREVIEW_DIV_CPU		AP1302_REG_32BIT(0x2050)
+#define AP1302_PREVIEW_DIV_IPIPE	AP1302_REG_32BIT(0x2054)
+#define AP1302_PREVIEW_DIV_SINF		AP1302_REG_32BIT(0x2058)
+#define AP1302_PREVIEW_DIV_HINF		AP1302_REG_32BIT(0x205C)
+#define AP1302_PREVIEW_DIV_HINF_MIPI	AP1302_REG_32BIT(0x2064)
+#define AP1302_PREVIEW_DIV_IP		AP1302_REG_32BIT(0x2068)
+#define AP1302_PREVIEW_DIV_SPI		AP1302_REG_32BIT(0x206C)
+#define AP1302_PREVIEW_DIV_PRI_SENSOR	AP1302_REG_32BIT(0x2070)
+#define AP1302_PREVIEW_DIV_SEC_SENSOR	AP1302_REG_32BIT(0x2074)
 
 /* IQ Registers */
 #define AP1302_AE_CTRL			AP1302_REG_16BIT(0x5002)
@@ -291,6 +309,7 @@
 #define AP1302_DMA_CTRL_MODE_UNPACK		(4 << 0)
 #define AP1302_DMA_CTRL_MODE_OTP_READ		(5 << 0)
 #define AP1302_DMA_CTRL_MODE_SIP_PROBE		(6 << 0)
+#define AP1302_SIP_CHECKSUM			AP1302_REG_16BIT(0x6134)
 
 #define AP1302_BRIGHTNESS			AP1302_REG_16BIT(0x7000)
 #define AP1302_CONTRAST			AP1302_REG_16BIT(0x7002)
@@ -303,6 +322,8 @@
 #define AP1302_SIP_CRC				AP1302_REG_16BIT(0xf052)
 
 /* Advanced System Registers */
+#define AP1302_ADV_CLGEN_PLL_0_DIV		AP1302_REG_32BIT(0x00210024)
+#define AP1302_ADV_CLGEN_PLL_1_DIV		AP1302_REG_32BIT(0x00210028)
 #define AP1302_ADV_IRQ_SYS_INTE			AP1302_REG_32BIT(0x00230000)
 #define AP1302_ADV_IRQ_SYS_INTE_TEST_COUNT	BIT(25)
 #define AP1302_ADV_IRQ_SYS_INTE_HINF_1		BIT(24)
@@ -358,15 +379,15 @@
 struct ap1302_device;
 
 enum {
-	AP1302_PAD_SINK_0,
-	AP1302_PAD_SINK_1,
+	//AP1302_PAD_SINK_0,
+	//AP1302_PAD_SINK_1,
 	AP1302_PAD_SOURCE,
 	AP1302_PAD_MAX,
 };
-
 struct ap1302_format_info {
 	unsigned int code;
 	u16 out_fmt;
+	u16 mipi_ctrl;
 };
 
 struct ap1302_format {
@@ -390,6 +411,7 @@ struct ap1302_sensor_info {
 	unsigned int i2c_addr;
 	struct ap1302_size resolution;
 	u32 format;
+	u16 fps;
 	const struct ap1302_sensor_supply *supplies;
 };
 
@@ -417,6 +439,8 @@ struct ap1302_device {
 
 	struct gpio_desc *reset_gpio;
 	struct gpio_desc *standby_gpio;
+	struct gpio_desc *i2csel_gpio;
+	struct gpio_desc *isptrig_gpio;
 	struct clk *clock;
 	struct regmap *regmap16;
 	struct regmap *regmap32;
@@ -434,6 +458,9 @@ struct ap1302_device {
 	unsigned int width_factor;
 	bool streaming;
 
+	struct v4l2_captureparm streamcap;
+	struct v4l2_fract frame_interval;
+	struct v4l2_pix_format pix;
 	struct v4l2_ctrl_handler ctrls;
 
 	const struct ap1302_sensor_info *sensor_info;
@@ -443,6 +470,7 @@ struct ap1302_device {
 		struct dentry *dir;
 		struct mutex lock;
 		u32 sipm_addr;
+		u32 reg_addr;
 	} debugfs;
 };
 
@@ -452,25 +480,19 @@ static inline struct ap1302_device *to_ap1302(struct v4l2_subdev *sd)
 }
 
 struct ap1302_firmware_header {
-	u16 pll_init_size;
-	u16 crc;
+	u32 checksum;
+	u32 pll_init_size;
+	u32 total_size;
+	u32 dummy;
 } __packed;
 
 #define MAX_FW_LOAD_RETRIES 3
 
 static const struct ap1302_format_info supported_video_formats[] = {
 	{
-		.code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.code = MEDIA_BUS_FMT_UYVY8_2X8,
 		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
 			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_422,
-	}, {
-		.code = MEDIA_BUS_FMT_UYYVYY8_0_5X24,
-		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
-			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_420,
-	}, {
-		.code = MEDIA_BUS_FMT_VYYUYY8_1X24,
-		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
-			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_420,
 	},
 };
 
@@ -516,7 +538,34 @@ static const struct ap1302_sensor_info ap1302_sensor_info[] = {
 			{ "vdd", 0 },
 			{ NULL, 0 },
 		},
-	},
+	}, {
+		.model = "onnn,arx3a0",
+		.name = "arx3a0",
+		.i2c_addr = 0x36,
+		.resolution = { 1920, 1080 },
+		.fps = 30,
+		.format = MEDIA_BUS_FMT_UYVY8_2X8,
+		.supplies = (const struct ap1302_sensor_supply[]) {
+			{ "vaa", 0 },
+			{ "vddio", 0 },
+			{ "vdd", 0 },
+			{ NULL, 0 },
+		},
+	}, {
+		.model = "onnn,ar0430",
+		.name = "ar0430",
+		.i2c_addr = 0x36,
+		.resolution = { 2316, 1746 },
+		.fps = 30,
+		.format = MEDIA_BUS_FMT_UYVY8_2X8,
+		.supplies = (const struct ap1302_sensor_supply[]) {
+			{ "vddpll", 0 },
+			{ "vaa", 0 },
+			{ "vdd", 0 },
+			{ "vddio", 0 },
+			{ NULL, 0 },
+		},
+	}
 };
 
 static const struct ap1302_sensor_info ap1302_sensor_info_tpg = {
@@ -800,7 +849,39 @@ static int ap1302_sipm_write(struct ap1302_device *ap1302, unsigned int port,
 /* -----------------------------------------------------------------------------
  * Debugfs
  */
+static int ap1302_reg_addr_get(void *arg, u64 *val)
+{
+	struct ap1302_device *ap1302 = arg;
+
+	mutex_lock(&ap1302->debugfs.lock);
+	*val = ap1302->debugfs.reg_addr;
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return 0;
+}
 
+static int ap1302_reg_addr_set(void *arg, u64 val)
+{
+	struct ap1302_device *ap1302 = arg;
+
+	if (val & ~0x700ffff)
+		return -EINVAL;
+
+	switch ((val >> 24) & 7) {
+	case 1:
+	case 2:
+	case 4:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	mutex_lock(&ap1302->debugfs.lock);
+	ap1302->debugfs.reg_addr = val;
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return 0;
+}
 static int ap1302_sipm_addr_get(void *arg, u64 *val)
 {
 	struct ap1302_device *ap1302 = arg;
@@ -834,6 +915,53 @@ static int ap1302_sipm_addr_set(void *arg, u64 val)
 	return 0;
 }
 
+static int ap1302_reg_data_get(void *arg, u64 *val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 value;
+	u32 addr;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+
+	addr = ap1302->debugfs.reg_addr;
+	if (!addr) {
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	ret = ap1302_read(ap1302, addr, &value);
+	if (!ret)
+		*val = value;
+
+unlock:
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
+static int ap1302_reg_data_set(void *arg, u64 val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 addr;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+
+	addr = ap1302->debugfs.reg_addr;
+	if (!addr) {
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	ap1302_write(ap1302, addr, val, &ret);
+
+unlock:
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
 static int ap1302_sipm_data_get(void *arg, u64 *val)
 {
 	struct ap1302_device *ap1302 = arg;
@@ -979,6 +1107,24 @@ DEFINE_DEBUGFS_ATTRIBUTE(ap1302_sipm_addr_fops, ap1302_sipm_addr_get,
 			 ap1302_sipm_addr_set, "0x%08llx\n");
 DEFINE_DEBUGFS_ATTRIBUTE(ap1302_sipm_data_fops, ap1302_sipm_data_get,
 			 ap1302_sipm_data_set, "0x%08llx\n");
+/*
+ * The reg_addr and reg_data attributes expose access to the AP1302 I2C bus.
+ *
+ * To read or write a register, reg_addr has to first be written with the
+ * register address. The address is a 32-bit integer formatted as follows.
+ *
+ * 0000 0SSS 0000 0000 RRRR RRRR RRRR RRRR
+ *
+ * S: Size (1: 8-bit, 2: 16-bit, 4: 32-bit)
+ * R: Register address (16-bit)
+ *
+ * The reg_data attribute can then be read to read the register value, or
+ * written to write it.
+ */
+DEFINE_DEBUGFS_ATTRIBUTE(ap1302_reg_addr_fops, ap1302_reg_addr_get,
+			 ap1302_reg_addr_set, "0x%08llx\n");
+DEFINE_DEBUGFS_ATTRIBUTE(ap1302_reg_data_fops, ap1302_reg_data_get,
+			 ap1302_reg_data_set, "0x%08llx\n");
 
 /* The debugfs is to read and write mipi clk parameters tclk_post values */
 DEFINE_DEBUGFS_ATTRIBUTE(ap1302_mipi_tclk_post_fops, ap1302_mipi_tclk_post_get,
@@ -1003,6 +1149,10 @@ static void ap1302_debugfs_init(struct ap1302_device *ap1302)
 
 	ap1302->debugfs.dir = dir;
 
+	debugfs_create_file_unsafe("reg_addr", 0600, ap1302->debugfs.dir,
+				   ap1302, &ap1302_reg_addr_fops);
+	debugfs_create_file_unsafe("reg_data", 0600, ap1302->debugfs.dir,
+				   ap1302, &ap1302_reg_data_fops);
 	debugfs_create_file_unsafe("sipm_addr", 0600, ap1302->debugfs.dir,
 				   ap1302, &ap1302_sipm_addr_fops);
 	debugfs_create_file_unsafe("sipm_data", 0600, ap1302->debugfs.dir,
@@ -1023,68 +1173,6 @@ static void ap1302_debugfs_cleanup(struct ap1302_device *ap1302)
  * Power Handling
  */
 
-static int ap1302_power_on_sensors(struct ap1302_device *ap1302)
-{
-	struct ap1302_sensor *sensor;
-	unsigned int i, j;
-	int ret;
-
-	if (!ap1302->sensor_info->supplies)
-		return 0;
-
-	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
-		sensor = &ap1302->sensors[i];
-		ret = 0;
-
-		for (j = 0; j < sensor->num_supplies; ++j) {
-			unsigned int delay;
-
-			/*
-			 * We can't use regulator_bulk_enable() as it would
-			 * enable all supplies in parallel, breaking the sensor
-			 * power sequencing constraints.
-			 */
-			ret = regulator_enable(sensor->supplies[j].consumer);
-			if (ret < 0) {
-				dev_err(ap1302->dev,
-					"Failed to enable supply %u for sensor %u\n",
-					j, i);
-				goto error;
-			}
-
-			delay = ap1302->sensor_info->supplies[j].post_delay_us;
-			usleep_range(delay, delay + 100);
-		}
-	}
-
-	return 0;
-
-error:
-	for (; j > 0; --j)
-		regulator_disable(sensor->supplies[j - 1].consumer);
-
-	for (; i > 0; --i) {
-		sensor = &ap1302->sensors[i - 1];
-		regulator_bulk_disable(sensor->num_supplies, sensor->supplies);
-	}
-
-	return ret;
-}
-
-static void ap1302_power_off_sensors(struct ap1302_device *ap1302)
-{
-	unsigned int i;
-
-	if (!ap1302->sensor_info->supplies)
-		return;
-
-	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
-		struct ap1302_sensor *sensor = &ap1302->sensors[i];
-
-		regulator_bulk_disable(sensor->num_supplies, sensor->supplies);
-	}
-}
-
 static int ap1302_power_on(struct ap1302_device *ap1302)
 {
 	int ret;
@@ -1194,7 +1282,6 @@ static int ap1302_configure(struct ap1302_device *ap1302)
 	const struct ap1302_format *format = &ap1302->formats[AP1302_PAD_SOURCE];
 	unsigned int data_lanes = ap1302->bus_cfg.bus.mipi_csi2.num_data_lanes;
 	int ret = 0;
-
 	ap1302_write(ap1302, AP1302_PREVIEW_HINF_CTRL,
 		     AP1302_PREVIEW_HINF_CTRL_SPOOF |
 		     AP1302_PREVIEW_HINF_CTRL_MIPI_LANES(data_lanes), &ret);
@@ -1205,6 +1292,8 @@ static int ap1302_configure(struct ap1302_device *ap1302)
 		     format->format.height, &ret);
 	ap1302_write(ap1302, AP1302_PREVIEW_OUT_FMT,
 		     format->info->out_fmt, &ret);
+	ap1302_write(ap1302, AP1302_PREVIEW_MAX_FPS, ap1302->sensor_info->fps << 8, &ret);
+
 	if (ret < 0)
 		return ret;
 
@@ -1247,7 +1336,6 @@ static int ap1302_stall(struct ap1302_device *ap1302, bool stall)
 				    AP1302_SYS_START_STALL_MODE_DISABLED, NULL);
 	}
 }
-
 static int ap1302_set_mipi_t3_clk(struct ap1302_device *ap1302)
 {
 	unsigned int mipi_t3, t_clk_post, t_clk_pre;
@@ -1685,45 +1773,48 @@ static int ap1302_enum_frame_size(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_pad_config *cfg,
 				  struct v4l2_subdev_frame_size_enum *fse)
 {
-	struct ap1302_device *ap1302 = to_ap1302(sd);
 	unsigned int i;
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	const struct ap1302_size *resolution = &ap1302->sensor_info->resolution;
 
 	if (fse->index)
 		return -EINVAL;
+	/*
+	 * On the source pad, the AP1302 can freely scale within the
+	 * scaler's limits.
+	 */
+	for (i = 0; i < ARRAY_SIZE(supported_video_formats); i++) {
+		if (supported_video_formats[i].code == fse->code)
+			break;
+	}
 
-	if (fse->pad != AP1302_PAD_SOURCE) {
-		/*
-		 * On the sink pads, only the size produced by the sensor is
-		 * supported.
-		 */
-		if (fse->code != ap1302->sensor_info->format)
-			return -EINVAL;
+	if (i >= ARRAY_SIZE(supported_video_formats))
+		return -EINVAL;
 
-		fse->min_width = ap1302->sensor_info->resolution.width;
-		fse->min_height = ap1302->sensor_info->resolution.height;
-		fse->max_width = ap1302->sensor_info->resolution.width;
-		fse->max_height = ap1302->sensor_info->resolution.height;
-	} else {
-		/*
-		 * On the source pad, the AP1302 can freely scale within the
-		 * scaler's limits.
-		 */
-		for (i = 0; i < ARRAY_SIZE(supported_video_formats); i++) {
-			if (supported_video_formats[i].code == fse->code)
-				break;
-		}
+	fse->min_width = resolution->width;
+	fse->max_width = resolution->width;
+	fse->min_height = resolution->height;
+	fse->max_height = resolution->height;
 
-		if (i >= ARRAY_SIZE(supported_video_formats))
-			return -EINVAL;
+	return 0;
+}
 
-		fse->min_width = AP1302_MIN_WIDTH * ap1302->width_factor;
-		fse->min_height = AP1302_MIN_HEIGHT;
-		fse->max_width = AP1302_MAX_WIDTH;
-		fse->max_height = AP1302_MAX_HEIGHT;
-	}
+static int ap1302_enum_frame_interval(struct v4l2_subdev *sd,
+				      struct v4l2_subdev_pad_config *cfg,
+				      struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+
+	if (fie->pad != 0)
+		return -EINVAL;
+	if (fie->index)
+		return -EINVAL;
+
+	fie->interval.numerator = 1;
+	fie->interval.denominator = ap1302->sensor_info->fps;
 
 	return 0;
-}
+};
 
 static int ap1302_get_fmt(struct v4l2_subdev *sd,
 			  struct v4l2_subdev_pad_config *cfg,
@@ -1825,7 +1916,6 @@ static int ap1302_s_stream(struct v4l2_subdev *sd, int enable)
 	int ret;
 
 	mutex_lock(&ap1302->lock);
-
 	if (enable == ap1302->streaming)
 		goto done;
 
@@ -2105,7 +2195,6 @@ static int ap1302_subdev_registered(struct v4l2_subdev *sd)
 	struct ap1302_device *ap1302 = to_ap1302(sd);
 	unsigned int i;
 	int ret;
-
 	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
 		struct ap1302_sensor *sensor = &ap1302->sensors[i];
 
@@ -2117,7 +2206,6 @@ static int ap1302_subdev_registered(struct v4l2_subdev *sd)
 		ret = v4l2_device_register_subdev(sd->v4l2_dev, &sensor->sd);
 		if (ret)
 			return ret;
-
 		ret = media_create_pad_link(&sensor->sd.entity, 0,
 					    &sd->entity, i,
 					    MEDIA_LNK_FL_IMMUTABLE |
@@ -2137,6 +2225,7 @@ static const struct v4l2_subdev_pad_ops ap1302_pad_ops = {
 	.init_cfg = ap1302_init_cfg,
 	.enum_mbus_code = ap1302_enum_mbus_code,
 	.enum_frame_size = ap1302_enum_frame_size,
+	.enum_frame_interval = ap1302_enum_frame_interval,
 	.get_fmt = ap1302_get_fmt,
 	.set_fmt = ap1302_set_fmt,
 	.get_selection = ap1302_get_selection,
@@ -2161,74 +2250,6 @@ static const struct v4l2_subdev_internal_ops ap1302_subdev_internal_ops = {
 	.registered = ap1302_subdev_registered,
 };
 
-/* -----------------------------------------------------------------------------
- * Sensor
- */
-
-static int ap1302_sensor_enum_mbus_code(struct v4l2_subdev *sd,
-					struct v4l2_subdev_pad_config *cfg,
-					struct v4l2_subdev_mbus_code_enum *code)
-{
-	struct ap1302_sensor *sensor = to_ap1302_sensor(sd);
-	const struct ap1302_sensor_info *info = sensor->ap1302->sensor_info;
-
-	if (code->index)
-		return -EINVAL;
-
-	code->code = info->format;
-	return 0;
-}
-
-static int ap1302_sensor_enum_frame_size(struct v4l2_subdev *sd,
-					 struct v4l2_subdev_pad_config *cfg,
-					 struct v4l2_subdev_frame_size_enum *fse)
-{
-	struct ap1302_sensor *sensor = to_ap1302_sensor(sd);
-	const struct ap1302_sensor_info *info = sensor->ap1302->sensor_info;
-
-	if (fse->index)
-		return -EINVAL;
-
-	if (fse->code != info->format)
-		return -EINVAL;
-
-	fse->min_width = info->resolution.width;
-	fse->min_height = info->resolution.height;
-	fse->max_width = info->resolution.width;
-	fse->max_height = info->resolution.height;
-
-	return 0;
-}
-
-static int ap1302_sensor_get_fmt(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_pad_config *cfg,
-				 struct v4l2_subdev_format *fmt)
-{
-	struct ap1302_sensor *sensor = to_ap1302_sensor(sd);
-	const struct ap1302_sensor_info *info = sensor->ap1302->sensor_info;
-
-	memset(&fmt->format, 0, sizeof(fmt->format));
-
-	fmt->format.width = info->resolution.width;
-	fmt->format.height = info->resolution.height;
-	fmt->format.field = V4L2_FIELD_NONE;
-	fmt->format.code = info->format;
-	fmt->format.colorspace = V4L2_COLORSPACE_SRGB;
-
-	return 0;
-}
-
-static const struct v4l2_subdev_pad_ops ap1302_sensor_pad_ops = {
-	.enum_mbus_code = ap1302_sensor_enum_mbus_code,
-	.enum_frame_size = ap1302_sensor_enum_frame_size,
-	.get_fmt = ap1302_sensor_get_fmt,
-	.set_fmt = ap1302_sensor_get_fmt,
-};
-
-static const struct v4l2_subdev_ops ap1302_sensor_subdev_ops = {
-	.pad = &ap1302_sensor_pad_ops,
-};
-
 static int ap1302_sensor_parse_of(struct ap1302_device *ap1302,
 				  struct device_node *node)
 {
@@ -2262,98 +2283,6 @@ static int ap1302_sensor_parse_of(struct ap1302_device *ap1302,
 	return 0;
 }
 
-static void ap1302_sensor_dev_release(struct device *dev)
-{
-	of_node_put(dev->of_node);
-	kfree(dev);
-}
-
-static int ap1302_sensor_init(struct ap1302_sensor *sensor, unsigned int index)
-{
-	struct ap1302_device *ap1302 = sensor->ap1302;
-	struct v4l2_subdev *sd = &sensor->sd;
-	unsigned int i;
-	int ret;
-
-	sensor->index = index;
-
-	/*
-	 * Register a device for the sensor, to support usage of the regulator
-	 * API.
-	 */
-	sensor->dev = kzalloc(sizeof(*sensor->dev), GFP_KERNEL);
-	if (!sensor->dev)
-		return -ENOMEM;
-
-	sensor->dev->parent = ap1302->dev;
-	sensor->dev->of_node = of_node_get(sensor->of_node);
-	sensor->dev->release = &ap1302_sensor_dev_release;
-	dev_set_name(sensor->dev, "%s-%s.%u", dev_name(ap1302->dev),
-		     ap1302->sensor_info->name, index);
-
-	ret = device_register(sensor->dev);
-	if (ret < 0) {
-		dev_err(ap1302->dev,
-			"Failed to register device for sensor %u\n", index);
-		goto error;
-	}
-
-	/* Retrieve the power supplies for the sensor, if any. */
-	if (ap1302->sensor_info->supplies) {
-		const struct ap1302_sensor_supply *supplies =
-			ap1302->sensor_info->supplies;
-		unsigned int num_supplies;
-
-		for (num_supplies = 0; supplies[num_supplies].name; ++num_supplies)
-			;
-
-		sensor->supplies = devm_kcalloc(ap1302->dev, num_supplies,
-						sizeof(*sensor->supplies),
-						GFP_KERNEL);
-		if (!sensor->supplies) {
-			ret = -ENOMEM;
-			goto error;
-		}
-
-		for (i = 0; i < num_supplies; ++i)
-			sensor->supplies[i].supply = supplies[i].name;
-
-		ret = regulator_bulk_get(sensor->dev, num_supplies,
-					 sensor->supplies);
-		if (ret < 0) {
-			dev_err(ap1302->dev,
-				"Failed to get supplies for sensor %u\n", index);
-			goto error;
-		}
-
-		sensor->num_supplies = i;
-	}
-
-	sd->dev = sensor->dev;
-	v4l2_subdev_init(sd, &ap1302_sensor_subdev_ops);
-
-	snprintf(sd->name, sizeof(sd->name), "%s %u",
-		 ap1302->sensor_info->name, index);
-
-	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
-	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
-
-	ret = media_entity_pads_init(&sd->entity, 1, &sensor->pad);
-	if (ret < 0) {
-		dev_err(ap1302->dev,
-			"failed to initialize media entity for sensor %u: %d\n",
-			index, ret);
-		goto error;
-	}
-
-	return 0;
-
-error:
-	put_device(sensor->dev);
-	return ret;
-}
-
 static void ap1302_sensor_cleanup(struct ap1302_sensor *sensor)
 {
 	media_entity_cleanup(&sensor->sd.entity);
@@ -2396,7 +2325,7 @@ static int ap1302_request_firmware(struct ap1302_device *ap1302)
 		return -EINVAL;
 	}
 
-	dev_dbg(ap1302->dev, "Requesting firmware %s\n", name);
+	dev_info(ap1302->dev, "Requesting firmware %s\n", name);
 
 	ret = request_firmware(&ap1302->fw, name, ap1302->dev);
 	if (ret) {
@@ -2470,18 +2399,13 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 	unsigned int fw_size;
 	const u8 *fw_data;
 	unsigned int win_pos = 0;
-	unsigned int crc;
+	unsigned int checksum;
+	int cnt, val;
 	int ret;
-
 	fw_hdr = (const struct ap1302_firmware_header *)ap1302->fw->data;
 	fw_data = (u8 *)&fw_hdr[1];
 	fw_size = ap1302->fw->size - sizeof(*fw_hdr);
 
-	/* Clear the CRC register. */
-	ret = ap1302_write(ap1302, AP1302_SIP_CRC, 0xffff, NULL);
-	if (ret)
-		return ret;
-
 	/*
 	 * Load the PLL initialization settings, set the bootdata stage to 2 to
 	 * apply the basic_init_hp settings, and wait 1ms for the PLL to lock.
@@ -2495,6 +2419,14 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 	if (ret)
 		return ret;
 
+	/* see if PLL locks */
+	for (cnt = 0 ; !ret && (cnt < 10) ; cnt++) {
+		msleep(2);
+		ret = ap1302_read(ap1302, AP1302_SYS_START, &val);
+		if ((val & AP1302_SYS_START_PLL_LOCK))
+			break;
+	}
+
 	usleep_range(1000, 2000);
 
 	/* Load the rest of the bootdata content and verify the CRC. */
@@ -2503,17 +2435,22 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 	if (ret)
 		return ret;
 
-	msleep(40);
+	usleep_range(10000, 20000);
 
-	ret = ap1302_read(ap1302, AP1302_SIP_CRC, &crc);
-	if (ret)
-		return ret;
+	/* Adjust Host interface MIPI rate to use 4 data lane
+	 * For AR0430 -> 448Mbps
+	 * For ARX3A0 -> 896Mbps */
+	if (!strcmp(ap1302->sensor_info->model, AR0430_MODEL)) {
+		dev_info(ap1302->dev, "AR0430 Model Selected \n");
+		ap1302_write(ap1302, AP1302_PREVIEW_DIV_HINF_MIPI, 0x00030002, NULL);
+	}
 
-	if (crc != fw_hdr->crc) {
-		dev_warn(ap1302->dev,
-			 "CRC mismatch: expected 0x%04x, got 0x%04x\n",
-			 fw_hdr->crc, crc);
-		return -EAGAIN;
+	/* Check again if PLL is locked aftaer adjusting Host interface MIPI data rate of AP1302 */
+	for (cnt = 0 ; !ret && (cnt < 10) ; cnt++) {
+		msleep(2);
+		ret = ap1302_read(ap1302, AP1302_SYS_START, &val);
+		if ((val & AP1302_SYS_START_PLL_LOCK))
+			break;
 	}
 
 	/*
@@ -2524,6 +2461,19 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 	if (ret)
 		return ret;
 
+	usleep_range(20000, 40000);
+	ret = ap1302_read(ap1302, AP1302_SIP_CHECKSUM, &checksum);
+	if (!ret) {
+		if (checksum != fw_hdr->checksum) {
+			dev_warn(ap1302->dev,
+				 "checksum mismatch: expected 0x%04x, got 0x%04x\n",
+				 fw_hdr->checksum, checksum);
+			ret = -EAGAIN;
+		}
+	}
+	if (ret)
+		return ret;
+
 	/* The AP1302 starts outputting frames right after boot, stop it. */
 	ret = ap1302_stall(ap1302, true);
 	if (ret)
@@ -2571,14 +2521,6 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 	if (ret)
 		return ret;
 
-	/*
-	 * Power the sensors first, as the firmware will access them once it
-	 * gets loaded.
-	 */
-	ret = ap1302_power_on_sensors(ap1302);
-	if (ret < 0)
-		goto error_firmware;
-
 	/*
 	 * Load the firmware, retrying in case of CRC errors. The AP1302 is
 	 * reset with a full power cycle between each attempt.
@@ -2586,7 +2528,7 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 	for (retries = 0; retries < MAX_FW_LOAD_RETRIES; ++retries) {
 		ret = ap1302_power_on(ap1302);
 		if (ret < 0)
-			goto error_power_sensors;
+			goto error_firmware;
 
 		ret = ap1302_detect_chip(ap1302);
 		if (ret)
@@ -2606,15 +2548,13 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 		dev_err(ap1302->dev,
 			"Firmware load retries exceeded, aborting\n");
 		ret = -ETIMEDOUT;
-		goto error_power_sensors;
+		goto error_firmware;
 	}
 
 	return 0;
 
 error_power:
 	ap1302_power_off(ap1302);
-error_power_sensors:
-	ap1302_power_off_sensors(ap1302);
 error_firmware:
 	release_firmware(ap1302->fw);
 
@@ -2624,7 +2564,6 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 static void ap1302_hw_cleanup(struct ap1302_device *ap1302)
 {
 	ap1302_power_off(ap1302);
-	ap1302_power_off_sensors(ap1302);
 }
 
 /* -----------------------------------------------------------------------------
@@ -2648,12 +2587,11 @@ static int ap1302_config_v4l2(struct ap1302_device *ap1302)
 
 	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
 	sd->internal_ops = &ap1302_subdev_internal_ops;
-	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_ISP;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
 	sd->entity.ops = &ap1302_media_ops;
 
 	for (i = 0; i < ARRAY_SIZE(ap1302->pads); ++i)
-		ap1302->pads[i].flags = i == AP1302_PAD_SOURCE
-				      ? MEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;
+		ap1302->pads[i].flags = MEDIA_PAD_FL_SOURCE;
 
 	ret = media_entity_pads_init(&sd->entity, ARRAY_SIZE(ap1302->pads),
 				     ap1302->pads);
@@ -2699,7 +2637,7 @@ static int ap1302_parse_of(struct ap1302_device *ap1302)
 	int ret;
 
 	/* Clock */
-	ap1302->clock = devm_clk_get(ap1302->dev, NULL);
+	ap1302->clock = devm_clk_get(ap1302->dev, "xclk");
 	if (IS_ERR(ap1302->clock)) {
 		dev_err(ap1302->dev, "Failed to get clock: %ld\n",
 			PTR_ERR(ap1302->clock));
@@ -2723,7 +2661,26 @@ static int ap1302_parse_of(struct ap1302_device *ap1302)
 		return PTR_ERR(ap1302->standby_gpio);
 	}
 
-	/* Bus configuration */
+	/* request optional I2C address select pin */
+	ap1302->i2csel_gpio = devm_gpiod_get_optional(ap1302->dev, "i2csel",
+						      GPIOD_OUT_HIGH);
+	if (IS_ERR(ap1302->i2csel_gpio)) {
+		dev_err(ap1302->dev, "Can't get i2csel GPIO: %ld\n",
+			PTR_ERR(ap1302->i2csel_gpio));
+	} else {
+		gpiod_set_value(ap1302->i2csel_gpio, 1);
+	}
+
+	/* ISP Trigger Pin */
+	ap1302->isptrig_gpio = devm_gpiod_get_optional(ap1302->dev, "isptrig",
+						       GPIOD_OUT_HIGH);
+	if (IS_ERR(ap1302->isptrig_gpio)) {
+		dev_err(ap1302->dev, "Can't get isptrig GPIO: %ld\n",
+			PTR_ERR(ap1302->isptrig_gpio));
+	} else {
+		gpiod_set_value(ap1302->isptrig_gpio, 1);
+	}
+
 	ep = fwnode_graph_get_next_endpoint(dev_fwnode(ap1302->dev), NULL);
 	if (!ep)
 		return -EINVAL;
@@ -2785,7 +2742,6 @@ static int ap1302_parse_of(struct ap1302_device *ap1302)
 	}
 
 	ap1302->width_factor = num_sensors;
-
 done:
 	of_node_put(sensors);
 	return ret;
@@ -2812,7 +2768,6 @@ static void ap1302_cleanup(struct ap1302_device *ap1302)
 static int ap1302_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	struct ap1302_device *ap1302;
-	unsigned int i;
 	int ret;
 
 	ap1302 = devm_kzalloc(&client->dev, sizeof(*ap1302), GFP_KERNEL);
@@ -2844,17 +2799,8 @@ static int ap1302_probe(struct i2c_client *client, const struct i2c_device_id *i
 	if (ret < 0)
 		goto error;
 
-	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
-		struct ap1302_sensor *sensor = &ap1302->sensors[i];
-
-		if (!sensor->ap1302)
-			continue;
-
-		ret = ap1302_sensor_init(sensor, i);
-		if (ret < 0)
-			goto error;
-	}
-
+	ap1302->frame_interval.numerator = 1;
+	ap1302->frame_interval.denominator = ap1302->sensor_info->fps;
 	ret = ap1302_hw_init(ap1302);
 	if (ret)
 		goto error;
-- 
2.17.1

