From 0d6f690618ff28bfeae362df50b69d74531eeeb5 Mon Sep 17 00:00:00 2001
From: Tejas Patel <tejas.patel1@einfochips.com>
Date: Wed, 19 Jan 2022 13:25:02 +0530
Subject: [PATCH 09/13] drivers: media: i2c: Modify AP1302 driver to work on
 IMX platform

This patch updates AP1302 driver so that it can work on
IMX platforms.

Change-Id: Ieda9fba02ee7d6613dd44071c5ba3abf9d940d88
Signed-off-by: Tejas Patel <tejas.patel1@einfochips.com>
Signed-off-by: Tanvi Chauhan <tanvi.chauhan@einfochips.com>
---
 drivers/media/i2c/ap1302.c | 579 +++++++++++++++++--------------------
 1 file changed, 261 insertions(+), 318 deletions(-)

diff --git a/drivers/media/i2c/ap1302.c b/drivers/media/i2c/ap1302.c
index 96da195c6..c276f9f0b 100644
--- a/drivers/media/i2c/ap1302.c
+++ b/drivers/media/i2c/ap1302.c
@@ -110,6 +110,9 @@
 #define AP1302_PREVIEW_ROI_X1			AP1302_REG_16BIT(0x2008)
 #define AP1302_PREVIEW_ROI_Y1			AP1302_REG_16BIT(0x200a)
 #define AP1302_PREVIEW_OUT_FMT			AP1302_REG_16BIT(0x2012)
+#define AP1302_PREVIEW_MIPI_CTRL		AP1302_REG_16BIT(0x2016)
+#define AP1302_PREVIEW_SENSOR_MODE		AP1302_REG_16BIT(0x2014)
+#define AP1302_PREVIEW_MAX_FPS			AP1302_REG_16BIT(0x2020)
 #define AP1302_PREVIEW_OUT_FMT_IPIPE_BYPASS	BIT(13)
 #define AP1302_PREVIEW_OUT_FMT_SS		BIT(12)
 #define AP1302_PREVIEW_OUT_FMT_FAKE_EN		BIT(11)
@@ -164,6 +167,19 @@
 #define AP1302_PREVIEW_HINF_CTRL_SPOOF		BIT(4)
 #define AP1302_PREVIEW_HINF_CTRL_MIPI_MODE	BIT(3)
 #define AP1302_PREVIEW_HINF_CTRL_MIPI_LANES(n)	((n) << 0)
+#define AP1302_SYSTEM_FREQ_IN		AP1302_REG_32BIT(0x6024)
+#define AP1302_SIPM_FREQ		AP1302_REG_32BIT(0x6028)
+#define AP1302_PLL_0_DIV		AP1302_REG_32BIT(0x602C)
+#define AP1302_PLL_1_DIV		AP1302_REG_32BIT(0x6038)
+#define AP1302_PREVIEW_DIV_CPU		AP1302_REG_32BIT(0x2050)
+#define AP1302_PREVIEW_DIV_IPIPE	AP1302_REG_32BIT(0x2054)
+#define AP1302_PREVIEW_DIV_SINF		AP1302_REG_32BIT(0x2058)
+#define AP1302_PREVIEW_DIV_HINF		AP1302_REG_32BIT(0x205C)
+#define AP1302_PREVIEW_DIV_HINF_MIPI	AP1302_REG_32BIT(0x2064)
+#define AP1302_PREVIEW_DIV_IP		AP1302_REG_32BIT(0x2068)
+#define AP1302_PREVIEW_DIV_SPI		AP1302_REG_32BIT(0x206C)
+#define AP1302_PREVIEW_DIV_PRI_SENSOR	AP1302_REG_32BIT(0x2070)
+#define AP1302_PREVIEW_DIV_SEC_SENSOR	AP1302_REG_32BIT(0x2074)
 
 /* IQ Registers */
 #define AP1302_AE_CTRL			AP1302_REG_16BIT(0x5002)
@@ -291,6 +307,7 @@
 #define AP1302_DMA_CTRL_MODE_UNPACK		(4 << 0)
 #define AP1302_DMA_CTRL_MODE_OTP_READ		(5 << 0)
 #define AP1302_DMA_CTRL_MODE_SIP_PROBE		(6 << 0)
+#define AP1302_SIP_CHECKSUM			AP1302_REG_16BIT(0x6134)
 
 #define AP1302_BRIGHTNESS			AP1302_REG_16BIT(0x7000)
 #define AP1302_CONTRAST			AP1302_REG_16BIT(0x7002)
@@ -303,6 +320,8 @@
 #define AP1302_SIP_CRC				AP1302_REG_16BIT(0xf052)
 
 /* Advanced System Registers */
+#define AP1302_ADV_CLGEN_PLL_0_DIV		AP1302_REG_32BIT(0x00210024)
+#define AP1302_ADV_CLGEN_PLL_1_DIV		AP1302_REG_32BIT(0x00210028)
 #define AP1302_ADV_IRQ_SYS_INTE			AP1302_REG_32BIT(0x00230000)
 #define AP1302_ADV_IRQ_SYS_INTE_TEST_COUNT	BIT(25)
 #define AP1302_ADV_IRQ_SYS_INTE_HINF_1		BIT(24)
@@ -358,15 +377,15 @@
 struct ap1302_device;
 
 enum {
-	AP1302_PAD_SINK_0,
-	AP1302_PAD_SINK_1,
+	//AP1302_PAD_SINK_0,
+	//AP1302_PAD_SINK_1,
 	AP1302_PAD_SOURCE,
 	AP1302_PAD_MAX,
 };
-
 struct ap1302_format_info {
 	unsigned int code;
 	u16 out_fmt;
+	u16 mipi_ctrl;
 };
 
 struct ap1302_format {
@@ -390,6 +409,7 @@ struct ap1302_sensor_info {
 	unsigned int i2c_addr;
 	struct ap1302_size resolution;
 	u32 format;
+	u16 fps;
 	const struct ap1302_sensor_supply *supplies;
 };
 
@@ -417,6 +437,8 @@ struct ap1302_device {
 
 	struct gpio_desc *reset_gpio;
 	struct gpio_desc *standby_gpio;
+	struct gpio_desc *i2csel_gpio;
+	struct gpio_desc *isptrig_gpio;
 	struct clk *clock;
 	struct regmap *regmap16;
 	struct regmap *regmap32;
@@ -434,6 +456,9 @@ struct ap1302_device {
 	unsigned int width_factor;
 	bool streaming;
 
+	struct v4l2_captureparm streamcap;
+	struct v4l2_fract frame_interval;
+	struct v4l2_pix_format pix;
 	struct v4l2_ctrl_handler ctrls;
 
 	const struct ap1302_sensor_info *sensor_info;
@@ -443,6 +468,7 @@ struct ap1302_device {
 		struct dentry *dir;
 		struct mutex lock;
 		u32 sipm_addr;
+		u32 reg_addr;
 	} debugfs;
 };
 
@@ -452,25 +478,19 @@ static inline struct ap1302_device *to_ap1302(struct v4l2_subdev *sd)
 }
 
 struct ap1302_firmware_header {
-	u16 pll_init_size;
-	u16 crc;
+	u32 checksum;
+	u32 pll_init_size;
+	u32 total_size;
+	u32 dummy;
 } __packed;
 
 #define MAX_FW_LOAD_RETRIES 3
 
 static const struct ap1302_format_info supported_video_formats[] = {
 	{
-		.code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.code = MEDIA_BUS_FMT_UYVY8_2X8,
 		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
 			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_422,
-	}, {
-		.code = MEDIA_BUS_FMT_UYYVYY8_0_5X24,
-		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
-			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_420,
-	}, {
-		.code = MEDIA_BUS_FMT_VYYUYY8_1X24,
-		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
-			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_420,
 	},
 };
 
@@ -516,7 +536,34 @@ static const struct ap1302_sensor_info ap1302_sensor_info[] = {
 			{ "vdd", 0 },
 			{ NULL, 0 },
 		},
-	},
+	}, {
+		.model = "onnn,arx3a0",
+		.name = "arx3a0",
+		.i2c_addr = 0x36,
+		.resolution = { 1920, 1080 },
+		.fps = 30,
+		.format = MEDIA_BUS_FMT_UYVY8_2X8,
+		.supplies = (const struct ap1302_sensor_supply[]) {
+			{ "vaa", 0 },
+			{ "vddio", 0 },
+			{ "vdd", 0 },
+			{ NULL, 0 },
+		},
+	}, {
+		.model = "onnn,ar0430",
+		.name = "ar0430",
+		.i2c_addr = 0x36,
+		.resolution = { 1920, 1080 },
+		.fps = 30,
+		.format = MEDIA_BUS_FMT_UYVY8_2X8,
+		.supplies = (const struct ap1302_sensor_supply[]) {
+			{ "vddpll", 0 },
+			{ "vaa", 0 },
+			{ "vdd", 0 },
+			{ "vddio", 0 },
+			{ NULL, 0 },
+		},
+	}
 };
 
 static const struct ap1302_sensor_info ap1302_sensor_info_tpg = {
@@ -800,7 +847,39 @@ static int ap1302_sipm_write(struct ap1302_device *ap1302, unsigned int port,
 /* -----------------------------------------------------------------------------
  * Debugfs
  */
+static int ap1302_reg_addr_get(void *arg, u64 *val)
+{
+	struct ap1302_device *ap1302 = arg;
+
+	mutex_lock(&ap1302->debugfs.lock);
+	*val = ap1302->debugfs.reg_addr;
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return 0;
+}
+
+static int ap1302_reg_addr_set(void *arg, u64 val)
+{
+	struct ap1302_device *ap1302 = arg;
+
+	if (val & ~0x700ffff)
+		return -EINVAL;
+
+	switch ((val >> 24) & 7) {
+	case 1:
+	case 2:
+	case 4:
+		break;
+	default:
+		return -EINVAL;
+	}
 
+	mutex_lock(&ap1302->debugfs.lock);
+	ap1302->debugfs.reg_addr = val;
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return 0;
+}
 static int ap1302_sipm_addr_get(void *arg, u64 *val)
 {
 	struct ap1302_device *ap1302 = arg;
@@ -834,6 +913,53 @@ static int ap1302_sipm_addr_set(void *arg, u64 val)
 	return 0;
 }
 
+static int ap1302_reg_data_get(void *arg, u64 *val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 value;
+	u32 addr;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+
+	addr = ap1302->debugfs.reg_addr;
+	if (!addr) {
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	ret = ap1302_read(ap1302, addr, &value);
+	if (!ret)
+		*val = value;
+
+unlock:
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
+static int ap1302_reg_data_set(void *arg, u64 val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 addr;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+
+	addr = ap1302->debugfs.reg_addr;
+	if (!addr) {
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	ap1302_write(ap1302, addr, val, &ret);
+
+unlock:
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
 static int ap1302_sipm_data_get(void *arg, u64 *val)
 {
 	struct ap1302_device *ap1302 = arg;
@@ -979,6 +1105,24 @@ DEFINE_DEBUGFS_ATTRIBUTE(ap1302_sipm_addr_fops, ap1302_sipm_addr_get,
 			 ap1302_sipm_addr_set, "0x%08llx\n");
 DEFINE_DEBUGFS_ATTRIBUTE(ap1302_sipm_data_fops, ap1302_sipm_data_get,
 			 ap1302_sipm_data_set, "0x%08llx\n");
+/*
+ * The reg_addr and reg_data attributes expose access to the AP1302 I2C bus.
+ *
+ * To read or write a register, reg_addr has to first be written with the
+ * register address. The address is a 32-bit integer formatted as follows.
+ *
+ * 0000 0SSS 0000 0000 RRRR RRRR RRRR RRRR
+ *
+ * S: Size (1: 8-bit, 2: 16-bit, 4: 32-bit)
+ * R: Register address (16-bit)
+ *
+ * The reg_data attribute can then be read to read the register value, or
+ * written to write it.
+ */
+DEFINE_DEBUGFS_ATTRIBUTE(ap1302_reg_addr_fops, ap1302_reg_addr_get,
+			 ap1302_reg_addr_set, "0x%08llx\n");
+DEFINE_DEBUGFS_ATTRIBUTE(ap1302_reg_data_fops, ap1302_reg_data_get,
+			 ap1302_reg_data_set, "0x%08llx\n");
 
 /* The debugfs is to read and write mipi clk parameters tclk_post values */
 DEFINE_DEBUGFS_ATTRIBUTE(ap1302_mipi_tclk_post_fops, ap1302_mipi_tclk_post_get,
@@ -1003,6 +1147,10 @@ static void ap1302_debugfs_init(struct ap1302_device *ap1302)
 
 	ap1302->debugfs.dir = dir;
 
+	debugfs_create_file_unsafe("reg_addr", 0600, ap1302->debugfs.dir,
+				   ap1302, &ap1302_reg_addr_fops);
+	debugfs_create_file_unsafe("reg_data", 0600, ap1302->debugfs.dir,
+				   ap1302, &ap1302_reg_data_fops);
 	debugfs_create_file_unsafe("sipm_addr", 0600, ap1302->debugfs.dir,
 				   ap1302, &ap1302_sipm_addr_fops);
 	debugfs_create_file_unsafe("sipm_data", 0600, ap1302->debugfs.dir,
@@ -1023,68 +1171,6 @@ static void ap1302_debugfs_cleanup(struct ap1302_device *ap1302)
  * Power Handling
  */
 
-static int ap1302_power_on_sensors(struct ap1302_device *ap1302)
-{
-	struct ap1302_sensor *sensor;
-	unsigned int i, j;
-	int ret;
-
-	if (!ap1302->sensor_info->supplies)
-		return 0;
-
-	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
-		sensor = &ap1302->sensors[i];
-		ret = 0;
-
-		for (j = 0; j < sensor->num_supplies; ++j) {
-			unsigned int delay;
-
-			/*
-			 * We can't use regulator_bulk_enable() as it would
-			 * enable all supplies in parallel, breaking the sensor
-			 * power sequencing constraints.
-			 */
-			ret = regulator_enable(sensor->supplies[j].consumer);
-			if (ret < 0) {
-				dev_err(ap1302->dev,
-					"Failed to enable supply %u for sensor %u\n",
-					j, i);
-				goto error;
-			}
-
-			delay = ap1302->sensor_info->supplies[j].post_delay_us;
-			usleep_range(delay, delay + 100);
-		}
-	}
-
-	return 0;
-
-error:
-	for (; j > 0; --j)
-		regulator_disable(sensor->supplies[j - 1].consumer);
-
-	for (; i > 0; --i) {
-		sensor = &ap1302->sensors[i - 1];
-		regulator_bulk_disable(sensor->num_supplies, sensor->supplies);
-	}
-
-	return ret;
-}
-
-static void ap1302_power_off_sensors(struct ap1302_device *ap1302)
-{
-	unsigned int i;
-
-	if (!ap1302->sensor_info->supplies)
-		return;
-
-	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
-		struct ap1302_sensor *sensor = &ap1302->sensors[i];
-
-		regulator_bulk_disable(sensor->num_supplies, sensor->supplies);
-	}
-}
-
 static int ap1302_power_on(struct ap1302_device *ap1302)
 {
 	int ret;
@@ -1194,7 +1280,6 @@ static int ap1302_configure(struct ap1302_device *ap1302)
 	const struct ap1302_format *format = &ap1302->formats[AP1302_PAD_SOURCE];
 	unsigned int data_lanes = ap1302->bus_cfg.bus.mipi_csi2.num_data_lanes;
 	int ret = 0;
-
 	ap1302_write(ap1302, AP1302_PREVIEW_HINF_CTRL,
 		     AP1302_PREVIEW_HINF_CTRL_SPOOF |
 		     AP1302_PREVIEW_HINF_CTRL_MIPI_LANES(data_lanes), &ret);
@@ -1205,6 +1290,8 @@ static int ap1302_configure(struct ap1302_device *ap1302)
 		     format->format.height, &ret);
 	ap1302_write(ap1302, AP1302_PREVIEW_OUT_FMT,
 		     format->info->out_fmt, &ret);
+	ap1302_write(ap1302, AP1302_PREVIEW_MAX_FPS, ap1302->sensor_info->fps << 8, &ret);
+
 	if (ret < 0)
 		return ret;
 
@@ -1247,7 +1334,6 @@ static int ap1302_stall(struct ap1302_device *ap1302, bool stall)
 				    AP1302_SYS_START_STALL_MODE_DISABLED, NULL);
 	}
 }
-
 static int ap1302_set_mipi_t3_clk(struct ap1302_device *ap1302)
 {
 	unsigned int mipi_t3, t_clk_post, t_clk_pre;
@@ -1652,6 +1738,10 @@ static int ap1302_init_cfg(struct v4l2_subdev *sd,
 		format->colorspace = V4L2_COLORSPACE_SRGB;
 	}
 
+	ap1302->pix.pixelformat = V4L2_PIX_FMT_UYVY;
+	ap1302->pix.width = info->resolution.width;
+	ap1302->pix.height = info->resolution.height;
+
 	return 0;
 }
 
@@ -1685,45 +1775,48 @@ static int ap1302_enum_frame_size(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_pad_config *cfg,
 				  struct v4l2_subdev_frame_size_enum *fse)
 {
-	struct ap1302_device *ap1302 = to_ap1302(sd);
 	unsigned int i;
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	const struct ap1302_size *resolution = &ap1302->sensor_info->resolution;
 
 	if (fse->index)
 		return -EINVAL;
+	/*
+	 * On the source pad, the AP1302 can freely scale within the
+	 * scaler's limits.
+	 */
+	for (i = 0; i < ARRAY_SIZE(supported_video_formats); i++) {
+		if (supported_video_formats[i].code == fse->code)
+			break;
+	}
+
+	if (i >= ARRAY_SIZE(supported_video_formats))
+		return -EINVAL;
 
-	if (fse->pad != AP1302_PAD_SOURCE) {
-		/*
-		 * On the sink pads, only the size produced by the sensor is
-		 * supported.
-		 */
-		if (fse->code != ap1302->sensor_info->format)
-			return -EINVAL;
+	fse->min_width = resolution->width;
+	fse->max_width = resolution->width;
+	fse->min_height = resolution->height;
+	fse->max_height = resolution->height;
 
-		fse->min_width = ap1302->sensor_info->resolution.width;
-		fse->min_height = ap1302->sensor_info->resolution.height;
-		fse->max_width = ap1302->sensor_info->resolution.width;
-		fse->max_height = ap1302->sensor_info->resolution.height;
-	} else {
-		/*
-		 * On the source pad, the AP1302 can freely scale within the
-		 * scaler's limits.
-		 */
-		for (i = 0; i < ARRAY_SIZE(supported_video_formats); i++) {
-			if (supported_video_formats[i].code == fse->code)
-				break;
-		}
+	return 0;
+}
 
-		if (i >= ARRAY_SIZE(supported_video_formats))
-			return -EINVAL;
+static int ap1302_enum_frame_interval(struct v4l2_subdev *sd,
+				      struct v4l2_subdev_pad_config *cfg,
+				      struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ap1302_device *ap1302 = to_ap1302(sd);
 
-		fse->min_width = AP1302_MIN_WIDTH * ap1302->width_factor;
-		fse->min_height = AP1302_MIN_HEIGHT;
-		fse->max_width = AP1302_MAX_WIDTH;
-		fse->max_height = AP1302_MAX_HEIGHT;
-	}
+	if (fie->pad != 0)
+		return -EINVAL;
+	if (fie->index)
+		return -EINVAL;
+
+	fie->interval.numerator = 1;
+	fie->interval.denominator = ap1302->sensor_info->fps;
 
 	return 0;
-}
+};
 
 static int ap1302_get_fmt(struct v4l2_subdev *sd,
 			  struct v4l2_subdev_pad_config *cfg,
@@ -1825,7 +1918,6 @@ static int ap1302_s_stream(struct v4l2_subdev *sd, int enable)
 	int ret;
 
 	mutex_lock(&ap1302->lock);
-
 	if (enable == ap1302->streaming)
 		goto done;
 
@@ -2105,7 +2197,6 @@ static int ap1302_subdev_registered(struct v4l2_subdev *sd)
 	struct ap1302_device *ap1302 = to_ap1302(sd);
 	unsigned int i;
 	int ret;
-
 	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
 		struct ap1302_sensor *sensor = &ap1302->sensors[i];
 
@@ -2117,7 +2208,6 @@ static int ap1302_subdev_registered(struct v4l2_subdev *sd)
 		ret = v4l2_device_register_subdev(sd->v4l2_dev, &sensor->sd);
 		if (ret)
 			return ret;
-
 		ret = media_create_pad_link(&sensor->sd.entity, 0,
 					    &sd->entity, i,
 					    MEDIA_LNK_FL_IMMUTABLE |
@@ -2137,6 +2227,7 @@ static const struct v4l2_subdev_pad_ops ap1302_pad_ops = {
 	.init_cfg = ap1302_init_cfg,
 	.enum_mbus_code = ap1302_enum_mbus_code,
 	.enum_frame_size = ap1302_enum_frame_size,
+	.enum_frame_interval = ap1302_enum_frame_interval,
 	.get_fmt = ap1302_get_fmt,
 	.set_fmt = ap1302_set_fmt,
 	.get_selection = ap1302_get_selection,
@@ -2161,74 +2252,6 @@ static const struct v4l2_subdev_internal_ops ap1302_subdev_internal_ops = {
 	.registered = ap1302_subdev_registered,
 };
 
-/* -----------------------------------------------------------------------------
- * Sensor
- */
-
-static int ap1302_sensor_enum_mbus_code(struct v4l2_subdev *sd,
-					struct v4l2_subdev_pad_config *cfg,
-					struct v4l2_subdev_mbus_code_enum *code)
-{
-	struct ap1302_sensor *sensor = to_ap1302_sensor(sd);
-	const struct ap1302_sensor_info *info = sensor->ap1302->sensor_info;
-
-	if (code->index)
-		return -EINVAL;
-
-	code->code = info->format;
-	return 0;
-}
-
-static int ap1302_sensor_enum_frame_size(struct v4l2_subdev *sd,
-					 struct v4l2_subdev_pad_config *cfg,
-					 struct v4l2_subdev_frame_size_enum *fse)
-{
-	struct ap1302_sensor *sensor = to_ap1302_sensor(sd);
-	const struct ap1302_sensor_info *info = sensor->ap1302->sensor_info;
-
-	if (fse->index)
-		return -EINVAL;
-
-	if (fse->code != info->format)
-		return -EINVAL;
-
-	fse->min_width = info->resolution.width;
-	fse->min_height = info->resolution.height;
-	fse->max_width = info->resolution.width;
-	fse->max_height = info->resolution.height;
-
-	return 0;
-}
-
-static int ap1302_sensor_get_fmt(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_pad_config *cfg,
-				 struct v4l2_subdev_format *fmt)
-{
-	struct ap1302_sensor *sensor = to_ap1302_sensor(sd);
-	const struct ap1302_sensor_info *info = sensor->ap1302->sensor_info;
-
-	memset(&fmt->format, 0, sizeof(fmt->format));
-
-	fmt->format.width = info->resolution.width;
-	fmt->format.height = info->resolution.height;
-	fmt->format.field = V4L2_FIELD_NONE;
-	fmt->format.code = info->format;
-	fmt->format.colorspace = V4L2_COLORSPACE_SRGB;
-
-	return 0;
-}
-
-static const struct v4l2_subdev_pad_ops ap1302_sensor_pad_ops = {
-	.enum_mbus_code = ap1302_sensor_enum_mbus_code,
-	.enum_frame_size = ap1302_sensor_enum_frame_size,
-	.get_fmt = ap1302_sensor_get_fmt,
-	.set_fmt = ap1302_sensor_get_fmt,
-};
-
-static const struct v4l2_subdev_ops ap1302_sensor_subdev_ops = {
-	.pad = &ap1302_sensor_pad_ops,
-};
-
 static int ap1302_sensor_parse_of(struct ap1302_device *ap1302,
 				  struct device_node *node)
 {
@@ -2262,98 +2285,6 @@ static int ap1302_sensor_parse_of(struct ap1302_device *ap1302,
 	return 0;
 }
 
-static void ap1302_sensor_dev_release(struct device *dev)
-{
-	of_node_put(dev->of_node);
-	kfree(dev);
-}
-
-static int ap1302_sensor_init(struct ap1302_sensor *sensor, unsigned int index)
-{
-	struct ap1302_device *ap1302 = sensor->ap1302;
-	struct v4l2_subdev *sd = &sensor->sd;
-	unsigned int i;
-	int ret;
-
-	sensor->index = index;
-
-	/*
-	 * Register a device for the sensor, to support usage of the regulator
-	 * API.
-	 */
-	sensor->dev = kzalloc(sizeof(*sensor->dev), GFP_KERNEL);
-	if (!sensor->dev)
-		return -ENOMEM;
-
-	sensor->dev->parent = ap1302->dev;
-	sensor->dev->of_node = of_node_get(sensor->of_node);
-	sensor->dev->release = &ap1302_sensor_dev_release;
-	dev_set_name(sensor->dev, "%s-%s.%u", dev_name(ap1302->dev),
-		     ap1302->sensor_info->name, index);
-
-	ret = device_register(sensor->dev);
-	if (ret < 0) {
-		dev_err(ap1302->dev,
-			"Failed to register device for sensor %u\n", index);
-		goto error;
-	}
-
-	/* Retrieve the power supplies for the sensor, if any. */
-	if (ap1302->sensor_info->supplies) {
-		const struct ap1302_sensor_supply *supplies =
-			ap1302->sensor_info->supplies;
-		unsigned int num_supplies;
-
-		for (num_supplies = 0; supplies[num_supplies].name; ++num_supplies)
-			;
-
-		sensor->supplies = devm_kcalloc(ap1302->dev, num_supplies,
-						sizeof(*sensor->supplies),
-						GFP_KERNEL);
-		if (!sensor->supplies) {
-			ret = -ENOMEM;
-			goto error;
-		}
-
-		for (i = 0; i < num_supplies; ++i)
-			sensor->supplies[i].supply = supplies[i].name;
-
-		ret = regulator_bulk_get(sensor->dev, num_supplies,
-					 sensor->supplies);
-		if (ret < 0) {
-			dev_err(ap1302->dev,
-				"Failed to get supplies for sensor %u\n", index);
-			goto error;
-		}
-
-		sensor->num_supplies = i;
-	}
-
-	sd->dev = sensor->dev;
-	v4l2_subdev_init(sd, &ap1302_sensor_subdev_ops);
-
-	snprintf(sd->name, sizeof(sd->name), "%s %u",
-		 ap1302->sensor_info->name, index);
-
-	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
-	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
-
-	ret = media_entity_pads_init(&sd->entity, 1, &sensor->pad);
-	if (ret < 0) {
-		dev_err(ap1302->dev,
-			"failed to initialize media entity for sensor %u: %d\n",
-			index, ret);
-		goto error;
-	}
-
-	return 0;
-
-error:
-	put_device(sensor->dev);
-	return ret;
-}
-
 static void ap1302_sensor_cleanup(struct ap1302_sensor *sensor)
 {
 	media_entity_cleanup(&sensor->sd.entity);
@@ -2470,18 +2401,13 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 	unsigned int fw_size;
 	const u8 *fw_data;
 	unsigned int win_pos = 0;
-	unsigned int crc;
+	unsigned int checksum;
+	int cnt, val;
 	int ret;
-
 	fw_hdr = (const struct ap1302_firmware_header *)ap1302->fw->data;
 	fw_data = (u8 *)&fw_hdr[1];
 	fw_size = ap1302->fw->size - sizeof(*fw_hdr);
 
-	/* Clear the CRC register. */
-	ret = ap1302_write(ap1302, AP1302_SIP_CRC, 0xffff, NULL);
-	if (ret)
-		return ret;
-
 	/*
 	 * Load the PLL initialization settings, set the bootdata stage to 2 to
 	 * apply the basic_init_hp settings, and wait 1ms for the PLL to lock.
@@ -2495,6 +2421,14 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 	if (ret)
 		return ret;
 
+	/* see if PLL locks */
+	for (cnt = 0 ; !ret && (cnt < 10) ; cnt++) {
+		msleep(2);
+		ret = ap1302_read(ap1302, AP1302_SYS_START, &val);
+		if ((val & AP1302_SYS_START_PLL_LOCK))
+			break;
+	}
+
 	usleep_range(1000, 2000);
 
 	/* Load the rest of the bootdata content and verify the CRC. */
@@ -2503,17 +2437,17 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 	if (ret)
 		return ret;
 
-	msleep(40);
+	usleep_range(10000, 20000);
 
-	ret = ap1302_read(ap1302, AP1302_SIP_CRC, &crc);
-	if (ret)
-		return ret;
+	// Adjust Host interface MIPI rate to use 4 data lane.
+	ap1302_write(ap1302, AP1302_PREVIEW_DIV_HINF_MIPI, 0x00030002, NULL);
 
-	if (crc != fw_hdr->crc) {
-		dev_warn(ap1302->dev,
-			 "CRC mismatch: expected 0x%04x, got 0x%04x\n",
-			 fw_hdr->crc, crc);
-		return -EAGAIN;
+	/* Check again if PLL is locked aftaer adjusting Host interface MIPI data rate of AP1302 */
+	for (cnt = 0 ; !ret && (cnt < 10) ; cnt++) {
+		msleep(2);
+		ret = ap1302_read(ap1302, AP1302_SYS_START, &val);
+		if ((val & AP1302_SYS_START_PLL_LOCK))
+			break;
 	}
 
 	/*
@@ -2524,6 +2458,19 @@ static int ap1302_load_firmware(struct ap1302_device *ap1302)
 	if (ret)
 		return ret;
 
+	usleep_range(20000, 40000);
+	ret = ap1302_read(ap1302, AP1302_SIP_CHECKSUM, &checksum);
+	if (!ret) {
+		if (checksum != fw_hdr->checksum) {
+			dev_warn(ap1302->dev,
+				 "checksum mismatch: expected 0x%04x, got 0x%04x\n",
+				 fw_hdr->checksum, checksum);
+			ret = -EAGAIN;
+		}
+	}
+	if (ret)
+		return ret;
+
 	/* The AP1302 starts outputting frames right after boot, stop it. */
 	ret = ap1302_stall(ap1302, true);
 	if (ret)
@@ -2571,14 +2518,6 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 	if (ret)
 		return ret;
 
-	/*
-	 * Power the sensors first, as the firmware will access them once it
-	 * gets loaded.
-	 */
-	ret = ap1302_power_on_sensors(ap1302);
-	if (ret < 0)
-		goto error_firmware;
-
 	/*
 	 * Load the firmware, retrying in case of CRC errors. The AP1302 is
 	 * reset with a full power cycle between each attempt.
@@ -2586,7 +2525,7 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 	for (retries = 0; retries < MAX_FW_LOAD_RETRIES; ++retries) {
 		ret = ap1302_power_on(ap1302);
 		if (ret < 0)
-			goto error_power_sensors;
+			goto error_firmware;
 
 		ret = ap1302_detect_chip(ap1302);
 		if (ret)
@@ -2606,15 +2545,13 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 		dev_err(ap1302->dev,
 			"Firmware load retries exceeded, aborting\n");
 		ret = -ETIMEDOUT;
-		goto error_power_sensors;
+		goto error_firmware;
 	}
 
 	return 0;
 
 error_power:
 	ap1302_power_off(ap1302);
-error_power_sensors:
-	ap1302_power_off_sensors(ap1302);
 error_firmware:
 	release_firmware(ap1302->fw);
 
@@ -2624,7 +2561,6 @@ static int ap1302_hw_init(struct ap1302_device *ap1302)
 static void ap1302_hw_cleanup(struct ap1302_device *ap1302)
 {
 	ap1302_power_off(ap1302);
-	ap1302_power_off_sensors(ap1302);
 }
 
 /* -----------------------------------------------------------------------------
@@ -2648,12 +2584,11 @@ static int ap1302_config_v4l2(struct ap1302_device *ap1302)
 
 	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
 	sd->internal_ops = &ap1302_subdev_internal_ops;
-	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_ISP;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
 	sd->entity.ops = &ap1302_media_ops;
 
 	for (i = 0; i < ARRAY_SIZE(ap1302->pads); ++i)
-		ap1302->pads[i].flags = i == AP1302_PAD_SOURCE
-				      ? MEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;
+		ap1302->pads[i].flags = MEDIA_PAD_FL_SOURCE;
 
 	ret = media_entity_pads_init(&sd->entity, ARRAY_SIZE(ap1302->pads),
 				     ap1302->pads);
@@ -2699,7 +2634,7 @@ static int ap1302_parse_of(struct ap1302_device *ap1302)
 	int ret;
 
 	/* Clock */
-	ap1302->clock = devm_clk_get(ap1302->dev, NULL);
+	ap1302->clock = devm_clk_get(ap1302->dev, "xclk");
 	if (IS_ERR(ap1302->clock)) {
 		dev_err(ap1302->dev, "Failed to get clock: %ld\n",
 			PTR_ERR(ap1302->clock));
@@ -2723,7 +2658,26 @@ static int ap1302_parse_of(struct ap1302_device *ap1302)
 		return PTR_ERR(ap1302->standby_gpio);
 	}
 
-	/* Bus configuration */
+	/* request optional I2C address select pin */
+	ap1302->i2csel_gpio = devm_gpiod_get_optional(ap1302->dev, "i2csel",
+						      GPIOD_OUT_HIGH);
+	if (IS_ERR(ap1302->i2csel_gpio)) {
+		dev_err(ap1302->dev, "Can't get i2csel GPIO: %ld\n",
+			PTR_ERR(ap1302->i2csel_gpio));
+	} else {
+		gpiod_set_value(ap1302->i2csel_gpio, 1);
+	}
+
+	/* ISP Trigger Pin */
+	ap1302->isptrig_gpio = devm_gpiod_get_optional(ap1302->dev, "isptrig",
+						       GPIOD_OUT_HIGH);
+	if (IS_ERR(ap1302->isptrig_gpio)) {
+		dev_err(ap1302->dev, "Can't get isptrig GPIO: %ld\n",
+			PTR_ERR(ap1302->isptrig_gpio));
+	} else {
+		gpiod_set_value(ap1302->isptrig_gpio, 1);
+	}
+
 	ep = fwnode_graph_get_next_endpoint(dev_fwnode(ap1302->dev), NULL);
 	if (!ep)
 		return -EINVAL;
@@ -2785,7 +2739,6 @@ static int ap1302_parse_of(struct ap1302_device *ap1302)
 	}
 
 	ap1302->width_factor = num_sensors;
-
 done:
 	of_node_put(sensors);
 	return ret;
@@ -2812,7 +2765,6 @@ static void ap1302_cleanup(struct ap1302_device *ap1302)
 static int ap1302_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	struct ap1302_device *ap1302;
-	unsigned int i;
 	int ret;
 
 	ap1302 = devm_kzalloc(&client->dev, sizeof(*ap1302), GFP_KERNEL);
@@ -2844,17 +2796,8 @@ static int ap1302_probe(struct i2c_client *client, const struct i2c_device_id *i
 	if (ret < 0)
 		goto error;
 
-	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
-		struct ap1302_sensor *sensor = &ap1302->sensors[i];
-
-		if (!sensor->ap1302)
-			continue;
-
-		ret = ap1302_sensor_init(sensor, i);
-		if (ret < 0)
-			goto error;
-	}
-
+	ap1302->frame_interval.numerator = 1;
+	ap1302->frame_interval.denominator = ap1302->sensor_info->fps;
 	ret = ap1302_hw_init(ap1302);
 	if (ret)
 		goto error;
-- 
2.17.1

